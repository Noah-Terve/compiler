/* Implementation of a singly directed graph in Wampus, and a BFS and DFS on it */

/* the thing that our nodes of the graph hold is polymorphic! 
 * nodes don't know what they are connected to, the outer graph does that*/
template @l T @r
struct node {
    string name; /* so we can tell nodes apart easily */
    T data;
    set @l string @r connections;
};


template @l T @r 
struct Graph {
    set @l node @l T @r @r nodes; /* saying we have a set of nodes which are of type T */
    int num_nodes;
};

/* make a new graph which stores things of type T */
/* doesnt work right now as returns for structs and lists are broken */
template @l T @r 
Graph @l T @r new_graph() {
    /* being pedantic about making sure initialize all variables */
    Graph @l T @r g;
    g.nodes = {}; /* empty set */
    g.num_nodes = 0;
    return g;
}

template @l T @r
bool has_node (Graph @l T @r g, string name) {
    if (g.num_nodes == 0) {
        return false;
    }
    int len = list_length @l node @l T @r @r (g.nodes);
    for (int i = 0; i < len; i += 1) {
        node @l int @r n = list_at @l node @l T @r @r (g.nodes, i);
        if (n.name == name) {
            return true;
        }
    }
    return false;
}

/* add a node: takes in a node to add */
template @l T @r
int add_node(Graph @l T @r g, node @l T @r n) {
    if (list_contains @l node @l T @r @r (g.nodes, n)) return 0; /* if the node is already in the graph dont do anything */
    
    /* go through the connections and make sure they are in the graph */
    int len = list_length @l string @r (n.connections);
    for (int i = len - 1; i >= 0; i += 1) {
        /* treating a set like a list */
        string name = list_at @l string @r (n.connections, i);
        if (!has_node @l T @r (g, name)) {
            list_remove @l string @r (n.connections, i);
        }
    }

    set_add @l node @l T @r @r (g.nodes, n); /* add n into the set of nodes */
    g.num_nodes += 1;
    return 0; /* no void functions :( */
}

/* assumes first level nodes */
tempalte @l T @r
int print_node (node @l T @r n) {
    print @l string @r ("Node: " + n.name + ", contains information: ");
    println @l T @r (n.data);
    print @l string @r ("It is connected to: ");
    int len = list_length @l string @r (n.connections);
    for (int i = 0; i < len; i += 1) {
        print @l string @r (list_at @l string @r (n.connections, i));
    }
    println @l string @r ("");
    println @l string @r ("");
    return 0;
}


/* assumes graphs are first level (i.e. store only basic types) */
template @l T @r
int print_graph (Graph @l T @r g) {
    print @l string @r ("Graph contians the following nodes:");
    for (int i = 0; i < g.num_nodes; i += 1) {
        print_node @l T @r (list_at @l node @l T @r @r (g.nodes, i));
    }
}



/* remove a node, identified by name, make sure to also go through and remove
 * other node's connections to it. */
/*
template @l T @r
int remove_node(Graph @l T @r g, node @l T @r n) {
    set_remove @l node @l T @r @r (g.nodes, n);
    g.num_nodes = set_size @l node @l T @r @r (g.nodes);
    return 0;
}
*/

/* add a connection from the node named n1 to the node named n2 */ /*
template @l T @r
Graph @l T @r add_connection(Graph @l T @r g, string n1, string n2) {
    /* easy beause of sets, just find which connection we need to add the n2 to*/ /*
    for (c in g.connections) {
        if (c.this == n1) {
            c.connections += n2;
            break;
        }
    }
    return g;
}
*/
/*
Graph @l int @r g = new_graph @l int @r();
*/
Graph @l int @r g = #l {}, 0 #r; 
    

node @l int @r n = #l "first", 3, {"hello"} #r;
/*
add_node @l int @r (g, n);

*/
println @l string @r ("");
println @l bool @r (has_node @l int @r (g, "1"));
/*
*/