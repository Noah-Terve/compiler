// This is a comment

// In the following example, we create a rudimentary map of the MBTA subway system

// We can declare and instantiate sets.
set<string> green_line = {"Medford/Tufts", "North Station", "Haymarket", "Government Center", "Park Street", "Arlington"};
set<string> orange_line = {"Oak Grove", "North Station", "Haymarket", "Downtown Crossing", "Mattapan"};

// We can add and remove individual elements from sets, too
// Note: there is no presendence for set opperations, they are done from left to right and parenthesis first, so 
// the two lines below do different things
set<string> old_orange_line = orange_line - "Mattapan" + "Forest Hills"; // Removes "Mattapan" and then adds "Forest Hills"
																												 								 // Resulting set is saved in orange_line
set<string> new_orange_line = orange_line - ("Forest Hills" + "Mattapan"); // Adds "Forest Hills" to "Mattapan" then
																												 					// subtracts both from the current orange line we havent decided 
																																	// if removing an element not in the set results in an error

// We can also add sets to other sets (union)
// note that + takes a set on one side and either another set or element of whatever type is in that set
// and returns a set that is both sets combined, but + does not modify the set on the left hand side of 
// the operator. += on the other hand takes the set on the left hand side and adds whatever is on the right
// into it.
set<string> red_line = {}; // We can create the empty set
red_line += {"Alewife", "Park Street", "Downtown Crossing"} + "Braintree";

// we can combine sets with union easily, this gives the set containing 
// all the elements in the green, red, and orange lines in no specified order
// Note that + is syntactic sugar for union when both operands are sets,
// both of the below lines do the same thing
set<string> the_t = union(green_line, orange_line, red_line);
set<string> also_the_t = green_line + orange_line + red_line

// you can get the intersection of sets easily with &
// this gives everything in the red and green line
set<string> all_red_and_green = (the_t & red_line) & green_line
// this gives just where the red and green line meet (park street)
set<string> red_and_green = red_line & green_line

            
// Other more simple functions that are available
const boston_tStops = {"Oak Grove", "North Station", "Haymarket", "Downtown Crossing", "Mattapan","Medford/Tufts", 
											"North Station", "Haymarket", "Government Center", "Park Street", "Arlington", "Other stations...."}


// Super set 
if superset(boston_tStops, green_line & red_line){
  print("Here are all the T stations in Boston")
  
}
else{
  print(boston_tstops - (green_line & red_line))
}

// Subset 
if subset(boston_tStops, green_line){
  print("Subset!: ", green_line)
  
}
else{
  print("The second parameter is not a subset of the first!")
}


                            
// Assume that a graph has been created outside of this function
// and that nodes are represented by strings, s is the inital node.
// note that this bfs doesn't actually do anything. it would need to
// edit the graph, but we have ommitted that part because we haven't
// actually written a graph
void BFS(T s, Graph<T> g)
{
    // Visited nodes as a set
  	// The set works like variables in c, where you can just create it, or
  	// make it with some values already in it. Below is an example of
  	// making it with nothing in it
    set<T> visited;
  
    // Create a queue for BFS
    array<T> queue;
 
    // Mark the current node as visited and enqueue it
  	// Note here that the set can just have things added into it
  	// no fancy business needed. This means add s to the set visited
    visited += s;
  
    // Function created for the queue
  	// push_back is a built in function for arrays
    push_back(queue, s);
 		
  	// empty and pop_front are built in functions for arrays
    while (!empty(queue)) {
        // Dequeue a vertex from queue
        s = pop_front(queue);
 
        // Get all adjacent vertices of the dequeued vertex s.
        // If an adjacent has not been visited, then mark it visited and enqueue it
      	// Note the use of in for the for loop, for every element (adjacent) in the 
      	// set adj do something. And the isin for the if statement (conditionals) 
        // both of these show how the set is easily accessible in programming other things.
      	set<T> adj = g.adjacent(s);
        for (adjacent in adj) {
            if (!(adjacent isin visited)) {
              	// set add functionality
                visited += adjacent;
                push_back(queue, adjacent);
            }
        }
    }
}
